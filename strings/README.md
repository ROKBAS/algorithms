# Префикс-функция. Алгоритм Кнута-Морриса-Пратта
# Prefix function. Knuth-Morris-Pratt algorithm
Например, для строки "abcabcd" префикс-функция равна: [0, 0, 0, 1, 2, 3, 0], что означает:

у строки "a" нет нетривиального префикса, совпадающего с суффиксом;
у строки "ab" нет нетривиального префикса, совпадающего с суффиксом;
у строки "abc" нет нетривиального префикса, совпадающего с суффиксом;
у строки "abca" префикс длины 1 совпадает с суффиксом;
у строки "abcab" префикс длины 2 совпадает с суффиксом;
у строки "abcabc" префикс длины 3 совпадает с суффиксом;
у строки "abcabcd" нет нетривиального префикса, совпадающего с суффиксом.
Другой пример — для строки "aabaaab" она равна: [0, 1, 0, 1, 2, 2, 3].

# Время работы
O(n) - эффективный алгоритм
Итак, алгоритм Кнута-Морриса-Пратта решает задачи поиска подстроки в строках за O(n+m) времени и O(n) памяти.

# Работа
Приведём здесь итоговую схему алгоритма:
Считать значения префикс-функции PF[i] будем по очереди: от i=1 к i=n-1 (значение PF[0] просто присвоим равным нулю).
Для подсчёта текущего значения PF[i] мы заводим переменную j, обозначающую длину текущего рассматриваемого образца. Изначально j = PF[i-1].
Тестируем образец длины j, для чего сравниваем символы s[j] и s[i]. Если они совпадают — то полагаем PF[i] = j+1 и переходим к следующему индексу i+1. Если же символы отличаются, то уменьшаем длину j, полагая её равной PF[j-1], и повторяем этот шаг алгоритма с начала.
Если мы дошли до длины j=0 и так и не нашли совпадения, то останавливаем процесс перебора образцов и полагаем PF[i] = 0 и переходим к следующему индексу i+1.